# ----------------------------------------- #
# Active Touch Laboratory - 2022 #
# Additional functions for specific use cases of FootSim #
# These functions are needed to reproduce a number of paper figures #

# Any questions contact Dr Rodrigo Siqueira at r.siqueiradesouza@sheffield.ac.uk #

# ----------------------------------------- #

import footsim as fs
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import seaborn as sns
import scipy
import time

# ----------------------------------------- #

# Hardcoded stimulus pairs from the experiments performed by Strzalkowski et al.  #

# ----------------------------------------- #

pairs = {'140827DPZ U02SAI': [(8, 0.05), (8, 0.075), (8, 0.1), (8, 0.25), (8, 0.5), (8, 0.75), (8, 1.0), (8, 1.25), (8, 1.5), (8, 1.75), (8, 2.0), (10, 0.05), (10, 0.075), (10, 0.1), (10, 0.25), (10, 0.5), (10, 0.75), (10, 1.0), (10, 1.25), (10, 1.5), (10, 1.75), (10, 2.0), (30, 0.005), (30, 0.0075), (30, 0.01), (30, 0.025), (30, 0.05), (30, 0.075), (30, 0.1), (30, 0.25), (30, 0.5), (30, 0.75), (30, 1.0), (30, 1.25), (30, 1.5), (30, 1.75), (30, 2.0), (150, 0.001), (150, 0.0025), (150, 0.005), (150, 0.0075), (150, 0.01), (150, 0.025), (150, 0.05), (150, 0.075), (150, 0.1), (150, 0.25)],
         '131003GG U01 SAI': [(3, 0.1), (3, 0.25), (3, 0.5), (3, 0.75), (3, 1.0), (3, 1.25), (3, 1.5), (5, 0.075), (5, 0.1), (5, 0.25), (5, 0.5), (5, 0.75), (5, 1.0), (5, 1.25), (5, 1.5), (5, 1.75), (5, 2.0), (8, 0.05), (8, 0.075), (8, 0.1), (8, 0.25), (8, 0.5), (8, 0.75), (8, 1.0), (8, 1.25), (8, 1.5), (8, 1.75), (8, 2.0), (10, 0.05), (10, 0.075), (10, 0.1), (10, 0.25), (10, 0.5), (10, 0.75), (10, 1.0), (10, 1.25), (10, 1.5), (10, 1.75), (10, 2.0), (20, 0.05), (20, 0.075), (20, 0.1), (20, 0.25), (20, 0.5), (20, 0.75), (20, 1.0), (20, 1.25), (20, 1.5), (20, 1.75), (20, 2.0), (30, 0.005), (30, 0.0075), (30, 0.01), (30, 0.025), (30, 0.05), (30, 0.075), (30, 0.1), (30, 0.25), (30, 0.5), (30, 0.75), (30, 1.0), (30, 1.25), (30, 1.5), (30, 1.75), (30, 2.0), (60, 0.001), (60, 0.0025), (60, 0.005), (60, 0.0075), (60, 0.01), (60, 0.025), (60, 0.05), (60, 0.075), (60, 0.1), (60, 0.25), (60, 0.5), (60, 0.75), (60, 1.0), (60, 1.25), (60, 1.5)],
         '130809LRF U01 SAI': [(3, 0.1), (3, 0.25), (3, 0.5), (3, 0.75), (3, 1.0), (3, 1.25), (3, 1.5), (3, 1.75), (3, 2.0), (5, 0.075), (5, 0.1), (5, 0.25), (5, 0.5), (5, 0.75), (5, 1.0), (5, 1.25), (5, 1.5), (5, 1.75), (5, 2.0), (8, 0.1), (8, 0.25), (8, 0.5), (8, 0.75), (8, 1.0), (8, 1.25), (8, 1.5), (8, 1.75), (10, 0.05), (10, 0.075), (10, 0.1), (10, 0.25), (10, 0.5), (10, 0.75), (10, 1.0), (10, 1.25), (10, 1.5), (10, 1.75), (10, 2.0), (20, 0.05), (20, 0.075), (20, 0.1), (20, 0.25), (20, 0.5), (20, 0.75), (20, 1.0), (20, 1.25), (20, 1.5), (20, 1.75), (20, 2.0), (30, 0.005), (30, 0.0075), (30, 0.01), (30, 0.025), (30, 0.05), (30, 0.075), (30, 0.1), (30, 0.25), (30, 0.5), (30, 0.75), (30, 1.0), (30, 1.25), (30, 1.5), (30, 1.75), (30, 2.0), (60, 0.001), (60, 0.0025), (60, 0.005), (60, 0.0075), (60, 0.01), (60, 0.025), (60, 0.05), (60, 0.075), (60, 0.1), (60, 0.25), (60, 0.5), (60, 0.75), (60, 1.0), (60, 1.25), (100, 0.001), (100, 0.0025), (100, 0.005), (100, 0.0075), (100, 0.01), (100, 0.025), (100, 0.05), (100, 0.075), (100, 0.1), (100, 0.25), (100, 0.5), (150, 0.001), (150, 0.0025), (150, 0.005), (150, 0.0075), (150, 0.01), (150, 0.025), (150, 0.05), (150, 0.075), (150, 0.1), (150, 0.25)],
         '130925RLM U01 SAI': [(3, 0.1), (3, 0.25), (3, 0.5), (3, 0.75), (3, 1.0), (3, 1.25), (3, 1.5), (8, 0.05), (8, 0.075), (8, 0.1), (8, 0.25), (8, 0.5), (8, 0.75), (8, 1.0), (8, 1.25), (8, 1.5), (8, 1.75), (8, 2.0), (10, 0.05), (10, 0.075), (10, 0.1), (10, 0.25), (10, 0.5), (10, 0.75), (10, 1.0), (10, 1.25), (10, 1.5), (10, 1.75), (10, 2.0), (20, 0.05), (20, 0.075), (20, 0.1), (20, 0.25), (20, 0.5), (20, 0.75), (20, 1.0), (20, 1.25), (20, 1.5), (20, 1.75), (20, 2.0), (30, 0.005), (30, 0.0075), (30, 0.01), (30, 0.025), (30, 0.05), (30, 0.075), (30, 0.1), (30, 0.25), (30, 0.5), (30, 0.75), (30, 1.0), (30, 1.25), (30, 1.5), (30, 1.75), (30, 2.0), (60, 0.001), (60, 0.0025), (60, 0.005), (60, 0.0075), (60, 0.01), (60, 0.025), (60, 0.05), (60, 0.075), (60, 0.1), (60, 0.25), (60, 0.5), (60, 0.75), (60, 1.0), (60, 1.25)],
         '140530SMB U01SAI': [(5, 0.075), (5, 0.1), (5, 0.25), (5, 0.5), (5, 0.75), (5, 1.0), (5, 1.25), (5, 1.5), (5, 1.75), (5, 2.0), (10, 0.05), (10, 0.075), (10, 0.1), (10, 0.25), (10, 0.5), (10, 0.75), (10, 1.0), (10, 1.25), (10, 1.5), (10, 1.75), (10, 2.0), (60, 0.001), (60, 0.0025), (60, 0.005), (60, 0.0075), (60, 0.01), (60, 0.025), (60, 0.05), (60, 0.075), (60, 0.1), (60, 0.25), (60, 0.5), (60, 0.75), (60, 1.0), (60, 1.25), (60, 1.5)],
         '130801AHH U01 FAI': [(3, 0.5), (3, 0.75), (3, 1.0), (3, 1.25), (3, 1.5), (3, 1.75), (3, 2.0), (5, 0.075), (5, 0.1), (5, 0.25), (5, 0.5), (5, 0.75), (5, 1.0), (5, 1.25), (5, 1.5), (5, 1.75), (5, 2.0), (10, 0.05), (10, 0.075), (10, 0.1), (10, 0.25), (10, 0.5), (10, 0.75), (10, 1.0), (10, 1.25), (10, 1.5), (10, 1.75), (10, 2.0), (20, 0.05), (20, 0.075), (20, 0.1), (20, 0.25), (20, 0.5), (20, 0.75), (20, 1.0), (20, 1.25), (20, 1.5), (20, 1.75), (20, 2.0), (30, 0.005), (30, 0.0075), (30, 0.01), (30, 0.025), (30, 0.05), (30, 0.075), (30, 0.1), (30, 0.25), (30, 0.5), (30, 0.75), (30, 1.0), (30, 1.25), (30, 1.5), (30, 1.75), (30, 2.0), (60, 0.001), (60, 0.0025), (60, 0.005), (60, 0.0075), (60, 0.01), (60, 0.025), (60, 0.05), (60, 0.075), (60, 0.1), (60, 0.25), (60, 0.5), (60, 0.75), (60, 1.0), (60, 1.25), (60, 1.5), (100, 0.001), (100, 0.0025), (100, 0.005), (100, 0.0075), (100, 0.01), (100, 0.025), (100, 0.05), (100, 0.075), (100, 0.1), (100, 0.25), (100, 0.5), (150, 0.001), (150, 0.0025), (150, 0.005), (150, 0.0075), (150, 0.01), (150, 0.025), (150, 0.05), (150, 0.075), (150, 0.1), (150, 0.25)],
         '140522AHH U01FAI': [(8, 0.05), (8, 0.075), (8, 0.1), (8, 0.25), (8, 0.5), (8, 0.75), (8, 1.0), (8, 1.25), (8, 1.5), (8, 1.75), (8, 2.0), (30, 0.005), (30, 0.0075), (30, 0.01), (30, 0.025), (30, 0.05), (30, 0.075), (30, 0.1), (30, 0.25), (30, 0.5), (30, 0.75), (30, 1.0), (30, 1.25), (30, 1.5), (30, 1.75), (30, 2.0), (100, 0.001), (100, 0.0025), (100, 0.005), (100, 0.0075), (100, 0.01), (100, 0.025), (100, 0.05), (100, 0.075), (100, 0.1), (100, 0.25), (100, 0.5)],
         '140611AJT U01FAI': [(5, 0.075), (5, 0.1), (5, 0.25), (5, 0.5), (5, 0.75), (5, 1.0), (5, 1.25), (5, 1.5), (5, 1.75), (5, 2.0), (8, 0.05), (8, 0.075), (8, 0.1), (8, 0.25), (8, 0.5), (8, 0.75), (8, 1.0), (8, 1.25), (8, 1.5), (8, 1.75), (8, 2.0), (10, 0.05), (10, 0.075), (10, 0.1), (10, 0.25), (10, 0.5), (10, 0.75), (10, 1.0), (10, 1.25), (10, 1.5), (10, 1.75), (10, 2.0), (20, 0.05), (20, 0.075), (20, 0.1), (20, 0.25), (20, 0.5), (20, 0.75), (20, 1.0), (20, 1.25), (20, 1.5), (20, 1.75), (20, 2.0), (30, 0.005), (30, 0.0075), (30, 0.01), (30, 0.025), (30, 0.05), (30, 0.075), (30, 0.1), (30, 0.25), (30, 0.5), (30, 0.75), (30, 1.0), (30, 1.25), (30, 1.5), (30, 1.75), (30, 2.0), (60, 0.001), (60, 0.0025), (60, 0.005), (60, 0.0075), (60, 0.01), (60, 0.025), (60, 0.05), (60, 0.075), (60, 0.1), (60, 0.25), (60, 0.5), (60, 0.75), (60, 1.0), (60, 1.25), (60, 1.5), (100, 0.001), (100, 0.0025), (100, 0.005), (100, 0.0075), (100, 0.01), (100, 0.025), (100, 0.05), (100, 0.075), (100, 0.1), (100, 0.25), (100, 0.5), (150, 0.001), (150, 0.0025), (150, 0.005), (150, 0.0075), (150, 0.01), (150, 0.025), (150, 0.05), (150, 0.075), (150, 0.1)],
         '140312AN U01FAI': [(8, 0.05), (8, 0.075), (8, 0.1), (8, 0.25), (8, 0.5), (8, 0.75), (8, 1.0), (8, 1.25), (8, 1.5), (8, 1.75), (8, 2.0), (20, 0.05), (20, 0.075), (20, 0.1), (20, 0.25), (20, 0.5), (20, 0.75), (20, 1.0), (20, 1.25), (20, 1.5), (20, 1.75), (20, 2.0), (30, 0.005), (30, 0.0075), (30, 0.01), (30, 0.025), (30, 0.05), (30, 0.075), (30, 0.1), (30, 0.25), (30, 0.5), (30, 0.75), (30, 1.0), (30, 1.25), (30, 1.5), (30, 1.75), (30, 2.0), (150, 0.001), (150, 0.0025), (150, 0.005), (150, 0.0075), (150, 0.01), (150, 0.025), (150, 0.05), (150, 0.075), (150, 0.1), (150, 0.25)],
         '130716CKL U02 FAI': [(3, 0.1), (3, 0.25), (3, 0.5), (3, 0.75), (3, 1.0), (3, 1.25), (30, 0.005), (30, 0.0075), (30, 0.01), (30, 0.025), (30, 0.05), (30, 0.075), (30, 0.1), (30, 0.25), (30, 0.5), (30, 0.75), (30, 1.0), (30, 1.25), (30, 1.5), (30, 1.75), (30, 2.0), (60, 0.001), (60, 0.0025), (60, 0.005), (60, 0.0075), (60, 0.01), (60, 0.025), (60, 0.05), (60, 0.075), (60, 0.1), (60, 0.25), (60, 0.5), (60, 0.75), (60, 1.0), (60, 1.25), (60, 1.5), (100, 0.001), (100, 0.0025), (100, 0.005), (100, 0.0075), (100, 0.01), (100, 0.025), (100, 0.05), (100, 0.075), (100, 0.1), (100, 0.25), (100, 0.5)],
         '131219CKL U02FAI': [(5, 0.075), (5, 0.1), (5, 0.25), (5, 0.5), (5, 0.75), (5, 1.0), (5, 1.25), (5, 1.5), (5, 1.75), (5, 2.0), (8, 0.05), (8, 0.075), (8, 0.1), (8, 0.25), (8, 0.5), (8, 0.75), (8, 1.0), (8, 1.25), (8, 1.5), (8, 1.75), (8, 2.0), (10, 0.05), (10, 0.075), (10, 0.1), (10, 0.25), (10, 0.5), (10, 0.75), (10, 1.0), (10, 1.25), (10, 1.5), (10, 1.75), (10, 2.0), (20, 0.05), (20, 0.075), (20, 0.1), (20, 0.25), (20, 0.5), (20, 0.75), (20, 1.0), (20, 1.25), (20, 1.5), (20, 1.75), (20, 2.0), (30, 0.005), (30, 0.0075), (30, 0.01), (30, 0.025), (30, 0.05), (30, 0.075), (30, 0.1), (30, 0.25), (30, 0.5), (30, 0.75), (30, 1.0), (30, 1.25), (30, 1.5), (30, 1.75), (30, 2.0), (60, 0.001), (60, 0.0025), (60, 0.005), (60, 0.0075), (60, 0.01), (60, 0.025), (60, 0.05), (60, 0.075), (60, 0.1), (60, 0.25), (60, 0.5), (60, 0.75), (60, 1.0), (60, 1.25), (100, 0.001), (100, 0.0025), (100, 0.005), (100, 0.0075), (100, 0.01), (100, 0.025), (100, 0.05), (100, 0.075), (100, 0.1), (100, 0.25), (100, 0.5)],
         '140123CKL U01FAI': [(5, 0.075), (5, 0.1), (5, 0.25), (5, 0.5), (5, 0.75), (5, 1.0), (5, 1.25), (5, 1.5), (5, 1.75), (5, 2.0), (20, 0.05), (20, 0.075), (20, 0.1), (20, 0.25), (20, 0.5), (20, 0.75), (20, 1.0), (20, 1.25), (20, 1.5), (20, 1.75), (20, 2.0), (30, 0.005), (30, 0.0075), (30, 0.01), (30, 0.025), (30, 0.05), (30, 0.075), (30, 0.1), (30, 0.25), (30, 0.5), (30, 0.75), (30, 1.0), (30, 1.25), (30, 1.5), (30, 1.75), (30, 2.0), (60, 0.001), (60, 0.0025), (60, 0.005), (60, 0.0075), (60, 0.01), (60, 0.025), (60, 0.05), (60, 0.075), (60, 0.1), (60, 0.25), (60, 0.5), (60, 0.75), (60, 1.0), (60, 1.25), (60, 1.5), (100, 0.001), (100, 0.0025), (100, 0.005), (100, 0.0075), (100, 0.01), (100, 0.025), (100, 0.05), (100, 0.075), (100, 0.1), (100, 0.25), (100, 0.5), (150, 0.001), (150, 0.0025), (150, 0.005), (150, 0.0075), (150, 0.01), (150, 0.025), (150, 0.05), (150, 0.075), (150, 0.1), (150, 0.25)],
         '140122DPZ U02FAI': [(3, 0.5), (3, 0.75), (3, 1.0), (3, 1.25), (3, 1.5), (3, 1.75), (3, 2.0), (5, 0.075), (5, 0.1), (5, 0.25), (5, 0.5), (5, 0.75), (5, 1.0), (5, 1.25), (5, 1.5), (5, 1.75), (5, 2.0), (8, 0.05), (8, 0.075), (8, 0.1), (8, 0.25), (8, 0.5), (8, 0.75), (8, 1.0), (8, 1.25), (8, 1.5), (8, 1.75), (8, 2.0), (10, 0.05), (10, 0.075), (10, 0.1), (10, 0.25), (10, 0.5), (10, 0.75), (10, 1.0), (10, 1.25), (10, 1.5), (10, 1.75), (10, 2.0), (20, 0.05), (20, 0.075), (20, 0.1), (20, 0.25), (20, 0.5), (20, 0.75), (20, 1.0), (20, 1.25), (20, 1.5), (20, 1.75), (20, 2.0), (30, 0.005), (30, 0.0075), (30, 0.01), (30, 0.025), (30, 0.05), (30, 0.075), (30, 0.1), (30, 0.25), (30, 0.5), (30, 0.75), (30, 1.0), (30, 1.25), (30, 1.5), (30, 1.75), (30, 2.0), (60, 0.001), (60, 0.0025), (60, 0.005), (60, 0.0075), (60, 0.01), (60, 0.025), (60, 0.05), (60, 0.075), (60, 0.1), (60, 0.25), (60, 0.5), (60, 0.75), (60, 1.0), (60, 1.25), (100, 0.001), (100, 0.0025), (100, 0.005), (100, 0.0075), (100, 0.01), (100, 0.025), (100, 0.05), (100, 0.075), (100, 0.1), (100, 0.25), (100, 0.5), (150, 0.001), (150, 0.0025), (150, 0.005), (150, 0.0075), (150, 0.01), (150, 0.025), (150, 0.05), (150, 0.075), (150, 0.1), (150, 0.25), (250, 0.001), (250, 0.0025), (250, 0.005), (250, 0.0075), (250, 0.01), (250, 0.025), (250, 0.05), (250, 0.075)],
         '140717DPZ U01FAI': [(3, 0.5), (3, 0.75), (3, 1.0), (3, 1.25), (3, 1.5), (3, 1.75), (3, 2.0), (5, 0.075), (5, 0.1), (5, 0.25), (5, 0.5), (5, 0.75), (5, 1.0), (5, 1.25), (5, 1.5), (8, 0.05), (8, 0.075), (8, 0.1), (8, 0.25), (8, 0.5), (8, 0.75), (8, 1.0), (8, 1.25), (8, 1.5), (8, 1.75), (8, 2.0), (10, 0.05), (10, 0.075), (10, 0.1), (10, 0.25), (10, 0.5), (10, 0.75), (10, 1.0), (10, 1.25), (10, 1.5), (10, 1.75), (10, 2.0), (20, 0.05), (20, 0.075), (20, 0.1), (20, 0.25), (20, 0.5), (20, 0.75), (20, 1.0), (20, 1.25), (20, 1.5), (20, 1.75), (20, 2.0), (30, 0.005), (30, 0.0075), (30, 0.01), (30, 0.025), (30, 0.05), (30, 0.075), (30, 0.1), (30, 0.25), (30, 0.5), (30, 0.75), (30, 1.0), (30, 1.25), (30, 1.5), (30, 1.75), (30, 2.0), (60, 0.001), (60, 0.0025), (60, 0.005), (60, 0.0075), (60, 0.01), (60, 0.025), (60, 0.05), (60, 0.075), (60, 0.1), (60, 0.25), (60, 0.5), (60, 0.75), (60, 1.0), (60, 1.25), (60, 1.5), (100, 0.001), (100, 0.0025), (100, 0.005), (100, 0.0075), (100, 0.01), (100, 0.025), (100, 0.05), (100, 0.075), (100, 0.1), (100, 0.25), (100, 0.5), (150, 0.001), (150, 0.0025), (150, 0.005), (150, 0.0075), (150, 0.01), (150, 0.025), (150, 0.05), (150, 0.075), (150, 0.1), (150, 0.25)],
         '131031LRF U01 FAI': [(3, 0.1), (3, 0.25), (3, 0.5), (3, 0.75), (3, 1.0), (3, 1.25), (3, 1.5), (3, 1.75), (3, 2.0), (5, 0.075), (5, 0.1), (5, 0.25), (5, 0.5), (5, 0.75), (5, 1.0), (5, 1.25), (5, 1.5), (5, 1.75), (5, 2.0), (8, 0.05), (8, 0.075), (8, 0.1), (8, 0.25), (8, 0.5), (8, 0.75), (8, 1.0), (8, 1.25), (8, 1.5), (8, 1.75), (8, 2.0), (10, 0.05), (10, 0.075), (10, 0.1), (10, 0.25), (10, 0.5), (10, 0.75), (10, 1.0), (10, 1.25), (10, 1.5), (10, 1.75), (10, 2.0), (20, 0.05), (20, 0.075), (20, 0.1), (20, 0.25), (20, 0.5), (20, 0.75), (20, 1.0), (20, 1.25), (20, 1.5), (20, 1.75), (20, 2.0), (30, 0.005), (30, 0.0075), (30, 0.01), (30, 0.025), (30, 0.05), (30, 0.075), (30, 0.1), (30, 0.25), (30, 0.5), (30, 0.75), (30, 1.0), (30, 1.25), (30, 1.5), (30, 1.75), (30, 2.0), (60, 0.001), (60, 0.0025), (60, 0.005), (60, 0.0075), (60, 0.01), (60, 0.025), (60, 0.05), (60, 0.075), (60, 0.1), (60, 0.25), (60, 0.5), (60, 0.75), (60, 1.0), (60, 1.25), (60, 1.5), (100, 0.001), (100, 0.0025), (100, 0.005), (100, 0.0075), (100, 0.01), (100, 0.025), (100, 0.05), (100, 0.075), (100, 0.1), (100, 0.25), (100, 0.5), (150, 0.001), (150, 0.0025), (150, 0.005), (150, 0.0075), (150, 0.01), (150, 0.025), (150, 0.05), (150, 0.075), (150, 0.1), (150, 0.25)],
         '140403LRF U02FAI': [(3, 0.5), (3, 0.75), (3, 1.0), (3, 1.25), (3, 1.5), (3, 1.75), (3, 2.0), (10, 0.05), (10, 0.075), (10, 0.1), (10, 0.25), (10, 0.5), (10, 0.75), (10, 1.0), (10, 1.25), (10, 1.5), (10, 1.75), (10, 2.0), (20, 0.05), (20, 0.075), (20, 0.1), (20, 0.25), (20, 0.5), (20, 0.75), (20, 1.0), (20, 1.25), (20, 1.5), (20, 1.75), (20, 2.0), (30, 0.005), (30, 0.0075), (30, 0.01), (30, 0.025), (30, 0.05), (30, 0.075), (30, 0.1), (30, 0.25), (30, 0.5), (30, 0.75), (30, 1.0), (30, 1.25), (30, 1.5), (30, 1.75), (30, 2.0)],
         '140514LRF U01FAI': [(5, 0.075), (5, 0.1), (5, 0.25), (5, 0.5), (5, 0.75), (5, 1.0), (5, 1.25), (5, 1.5), (5, 1.75), (8, 0.05), (8, 0.075), (8, 0.1), (8, 0.25), (8, 0.5), (8, 0.75), (8, 1.0), (8, 1.25), (8, 1.5), (8, 1.75), (8, 2.0), (20, 0.05), (20, 0.075), (20, 0.1), (20, 0.25), (20, 0.5), (20, 0.75), (20, 1.0), (20, 1.25), (20, 1.5), (20, 1.75), (20, 2.0), (30, 0.005), (30, 0.0075), (30, 0.01), (30, 0.025), (30, 0.05), (30, 0.075), (30, 0.1), (30, 0.25), (30, 0.5), (30, 0.75), (30, 1.0), (30, 1.25), (30, 1.5), (30, 1.75), (30, 2.0), (60, 0.001), (60, 0.0025), (60, 0.005), (60, 0.0075), (60, 0.01), (60, 0.025), (60, 0.05), (60, 0.075), (60, 0.1), (60, 0.25), (60, 0.5), (60, 0.75), (60, 1.0), (60, 1.25), (60, 1.5), (100, 0.001), (100, 0.0025), (100, 0.005), (100, 0.0075), (100, 0.01), (100, 0.025), (100, 0.05), (100, 0.075), (100, 0.1), (100, 0.25), (100, 0.5)],
         '120405MEG U01FAI': [(10, 0.75), (10, 1.0), (10, 1.25), (10, 1.5), (10, 1.75), (10, 2.0), (30, 0.05), (30, 0.075), (30, 0.1), (30, 0.25), (30, 0.5), (30, 0.75), (30, 1.0), (30, 1.25), (30, 1.5), (30, 1.75), (30, 2.0), (150, 0.1), (250, 0.075)],
         '140725PS U01FAI': [(5, 0.075), (5, 0.1), (5, 0.25), (5, 0.5), (5, 0.75), (5, 1.0), (5, 1.25), (5, 1.5), (5, 1.75), (5, 2.0), (8, 0.05), (8, 0.075), (8, 0.1), (8, 0.25), (8, 0.5), (8, 0.75), (8, 1.0), (8, 1.25), (8, 1.5), (8, 1.75), (8, 2.0), (10, 0.05), (10, 0.075), (10, 0.1), (10, 0.25), (10, 0.5), (10, 0.75), (10, 1.0), (10, 1.25), (10, 1.5), (10, 1.75), (10, 2.0), (20, 0.05), (20, 0.075), (20, 0.1), (20, 0.25), (20, 0.5), (20, 0.75), (20, 1.0), (20, 1.25), (20, 1.5), (20, 1.75), (20, 2.0), (30, 0.005), (30, 0.0075), (30, 0.01), (30, 0.025), (30, 0.05), (30, 0.075), (30, 0.1), (30, 0.25), (30, 0.5), (30, 0.75), (30, 1.0), (30, 1.25), (30, 1.5), (30, 1.75), (30, 2.0), (60, 0.001), (60, 0.0025), (60, 0.005), (60, 0.0075), (60, 0.01), (60, 0.025), (60, 0.05), (60, 0.075), (60, 0.1), (60, 0.25), (60, 0.5), (60, 0.75), (60, 1.0), (60, 1.25), (60, 1.5), (100, 0.001), (100, 0.0025), (100, 0.005), (100, 0.0075), (100, 0.01), (100, 0.025), (100, 0.05), (100, 0.075), (100, 0.1), (100, 0.25), (100, 0.5)],
         '140530SMB U02FAI': [(3, 0.5), (3, 0.75), (3, 1.0), (3, 1.25), (5, 0.075), (5, 0.1), (5, 0.25), (5, 0.5), (5, 0.75), (5, 1.0), (5, 1.25), (5, 1.5), (5, 1.75), (8, 0.05), (8, 0.075), (8, 0.1), (8, 0.25), (8, 0.5), (8, 0.75), (8, 1.0), (8, 1.25), (8, 1.5), (8, 1.75), (8, 2.0), (10, 0.05), (10, 0.075), (10, 0.1), (10, 0.25), (10, 0.5), (10, 0.75), (10, 1.0), (10, 1.25), (10, 1.5), (10, 1.75), (10, 2.0), (20, 0.05), (20, 0.075), (20, 0.1), (20, 0.25), (20, 0.5), (20, 0.75), (20, 1.0), (20, 1.25), (20, 1.5), (20, 1.75), (20, 2.0), (30, 0.005), (30, 0.0075), (30, 0.01), (30, 0.025), (30, 0.05), (30, 0.075), (30, 0.1), (30, 0.25), (30, 0.5), (30, 0.75), (30, 1.0), (30, 1.25), (30, 1.5), (30, 1.75), (30, 2.0), (60, 0.001), (60, 0.0025), (60, 0.005), (60, 0.0075), (60, 0.01), (60, 0.025), (60, 0.05), (60, 0.075), (60, 0.1), (60, 0.25), (60, 0.5), (60, 0.75), (60, 1.0), (60, 1.25), (100, 0.001), (100, 0.0025), (100, 0.005), (100, 0.0075), (100, 0.01), (100, 0.025), (100, 0.05), (100, 0.075), (100, 0.1), (100, 0.25), (100, 0.5), (150, 0.001), (150, 0.0025), (150, 0.005), (150, 0.0075), (150, 0.01), (150, 0.025), (150, 0.05), (150, 0.075), (150, 0.1), (150, 0.25), (250, 0.001), (250, 0.0025), (250, 0.005), (250, 0.0075), (250, 0.01), (250, 0.025), (250, 0.05)],
         '140813AHH U02FAII': [(8, 0.05), (8, 0.075), (8, 0.1), (8, 0.25), (8, 0.5), (8, 0.75), (60, 0.001), (60, 0.0025), (60, 0.005), (60, 0.0075), (60, 0.01), (60, 0.025), (60, 0.05), (60, 0.075), (60, 0.1), (60, 0.25), (60, 0.5), (60, 0.75), (60, 1.0), (60, 1.25), (60, 1.5), (150, 0.001), (150, 0.0025), (150, 0.005), (150, 0.0075), (150, 0.01), (150, 0.025), (150, 0.05), (150, 0.075), (150, 0.1), (150, 0.25), (250, 0.001), (250, 0.0025), (250, 0.005), (250, 0.0075), (250, 0.01), (250, 0.025), (250, 0.05), (250, 0.075)],
         '140424CKL U01FAII': [(5, 0.075), (5, 0.1), (5, 0.25), (5, 0.5), (5, 0.75), (5, 1.0), (5, 1.25), (5, 1.5), (8, 0.05), (8, 0.075), (8, 0.1), (8, 0.25), (8, 0.5), (8, 0.75), (8, 1.0), (8, 1.25), (8, 1.5), (8, 1.75), (8, 2.0), (10, 0.05), (10, 0.075), (10, 0.1), (10, 0.25), (10, 0.5), (10, 0.75), (10, 1.0), (10, 1.25), (10, 1.5), (10, 1.75), (10, 2.0), (20, 0.05), (20, 0.075), (20, 0.1), (20, 0.25), (20, 0.5), (20, 0.75), (20, 1.0), (20, 1.25), (20, 1.5), (20, 1.75), (20, 2.0), (30, 0.005), (30, 0.0075), (30, 0.01), (30, 0.025), (30, 0.05), (30, 0.075), (30, 0.1), (30, 0.25), (30, 0.5), (30, 0.75), (30, 1.0), (30, 1.25), (30, 1.5), (30, 1.75), (30, 2.0), (100, 0.001), (100, 0.0025), (100, 0.005), (100, 0.0075), (100, 0.01), (100, 0.025), (100, 0.05), (100, 0.075), (100, 0.1), (100, 0.25), (100, 0.5), (150, 0.001), (150, 0.0025), (150, 0.005), (150, 0.0075), (150, 0.01), (150, 0.025), (150, 0.05), (150, 0.075), (150, 0.1), (150, 0.25), (250, 0.001), (250, 0.0025), (250, 0.005), (250, 0.0075), (250, 0.01), (250, 0.025), (250, 0.05), (250, 0.075)],
         '140827DPZ U01FAII': [(3, 0.5), (3, 0.75), (3, 1.0), (3, 1.25), (3, 1.5), (8, 0.05), (8, 0.075), (8, 0.1), (8, 0.25), (8, 0.5), (8, 0.75), (8, 1.0), (8, 1.25), (8, 1.5), (8, 1.75), (8, 2.0), (10, 0.05), (10, 0.075), (10, 0.1), (10, 0.25), (10, 0.5), (10, 0.75), (10, 1.0), (10, 1.25), (10, 1.5), (10, 1.75), (10, 2.0), (30, 0.005), (30, 0.0075), (30, 0.01), (30, 0.025), (30, 0.05), (30, 0.075), (30, 0.1), (30, 0.25), (30, 0.5), (30, 0.75), (30, 1.0), (30, 1.25), (30, 1.5), (30, 1.75), (30, 2.0), (60, 0.001), (60, 0.0025), (60, 0.005), (60, 0.0075), (60, 0.01), (60, 0.025), (60, 0.05), (60, 0.075), (60, 0.1), (60, 0.25), (60, 0.5), (60, 0.75), (60, 1.0), (60, 1.25), (60, 1.5), (150, 0.001), (150, 0.0025), (150, 0.005), (150, 0.0075), (150, 0.01), (150, 0.025), (150, 0.05), (150, 0.075), (150, 0.1), (150, 0.25), (250, 0.001), (250, 0.0025), (250, 0.005), (250, 0.0075), (250, 0.01), (250, 0.025), (250, 0.05), (250, 0.075)],
         '140514LRF U02FAII': [(3, 0.5), (3, 0.75), (3, 1.0), (3, 1.25), (3, 1.5), (5, 0.075), (5, 0.1), (5, 0.25), (5, 0.5), (5, 0.75), (5, 1.0), (5, 1.25), (5, 1.5), (5, 1.75), (5, 2.0), (8, 0.05), (8, 0.075), (8, 0.1), (8, 0.25), (8, 0.5), (8, 0.75), (8, 1.0), (8, 1.25), (8, 1.5), (8, 1.75), (8, 2.0), (10, 0.05), (10, 0.075), (10, 0.1), (10, 0.25), (10, 0.5), (10, 0.75), (10, 1.0), (10, 1.25), (10, 1.5), (10, 1.75), (10, 2.0), (20, 0.05), (20, 0.075), (20, 0.1), (20, 0.25), (20, 0.5), (20, 0.75), (20, 1.0), (20, 1.25), (20, 1.5), (20, 1.75), (20, 2.0), (30, 0.005), (30, 0.0075), (30, 0.01), (30, 0.025), (30, 0.05), (30, 0.075), (30, 0.1), (30, 0.25), (30, 0.5), (30, 0.75), (30, 1.0), (30, 1.25), (30, 1.5), (30, 1.75), (30, 2.0), (60, 0.001), (60, 0.0025), (60, 0.005), (60, 0.0075), (60, 0.01), (60, 0.025), (60, 0.05), (60, 0.075), (60, 0.1), (60, 0.25), (60, 0.5), (60, 0.75), (60, 1.0), (60, 1.25), (60, 1.5), (100, 0.001), (100, 0.0025), (100, 0.005), (100, 0.0075), (100, 0.01), (100, 0.025), (100, 0.05), (100, 0.075), (100, 0.1), (100, 0.25), (100, 0.5)],
         '130925RLM U02 FAII': [(8, 0.05), (8, 0.075), (8, 0.1), (8, 0.25), (8, 0.5), (8, 0.75), (8, 1.0), (8, 1.25), (8, 1.5), (8, 1.75), (8, 2.0), (10, 0.05), (10, 0.075), (10, 0.1), (10, 0.25), (10, 0.5), (10, 0.75), (10, 1.0), (10, 1.25), (10, 1.5), (10, 1.75), (10, 2.0), (20, 0.05), (20, 0.075), (20, 0.1), (20, 0.25), (20, 0.5), (20, 0.75), (20, 1.0), (20, 1.25), (20, 1.5), (20, 1.75), (20, 2.0), (30, 0.005), (30, 0.0075), (30, 0.01), (30, 0.025), (30, 0.05), (30, 0.075), (30, 0.1), (30, 0.25), (30, 0.5), (30, 0.75), (30, 1.0), (30, 1.25), (30, 1.5), (30, 1.75), (30, 2.0), (60, 0.001), (60, 0.0025), (60, 0.005), (60, 0.0075), (60, 0.01), (60, 0.025), (60, 0.05), (60, 0.075), (60, 0.1), (60, 0.25), (60, 0.5), (60, 0.75), (60, 1.0), (60, 1.25), (100, 0.001), (100, 0.0025), (100, 0.005), (100, 0.0075), (100, 0.01), (100, 0.025), (100, 0.05), (100, 0.075), (100, 0.1), (100, 0.25), (100, 0.5)],
         '140522AHH U02SAII': [(3, 0.5), (3, 0.75), (3, 1.0), (3, 1.25), (3, 1.5), (3, 1.75), (3, 2.0), (5, 0.075), (5, 0.1), (5, 0.25), (5, 0.5), (5, 0.75), (5, 1.0), (5, 1.25), (5, 1.5), (5, 1.75), (10, 0.05), (10, 0.075), (10, 0.1), (10, 0.25), (10, 0.5), (10, 0.75), (10, 1.0), (10, 1.25), (10, 1.5), (10, 1.75), (10, 2.0), (20, 0.05), (20, 0.075), (20, 0.1), (20, 0.25), (20, 0.5), (20, 0.75), (20, 1.0), (20, 1.25), (20, 1.5), (20, 1.75), (20, 2.0), (30, 0.005), (30, 0.0075), (30, 0.01), (30, 0.025), (30, 0.05), (30, 0.075), (30, 0.1), (30, 0.25), (30, 0.5), (30, 0.75), (30, 1.0), (30, 1.25), (30, 1.5), (30, 1.75), (30, 2.0), (60, 0.001), (60, 0.0025), (60, 0.005), (60, 0.0075), (60, 0.01), (60, 0.025), (60, 0.05), (60, 0.075), (60, 0.1), (60, 0.25), (60, 0.5), (60, 0.75), (60, 1.0), (60, 1.25)],
         '131205AYK U01SAII': [(3, 0.5), (3, 0.75), (3, 1.0), (3, 1.25), (3, 1.5), (5, 0.075), (5, 0.1), (5, 0.25), (5, 0.5), (5, 0.75), (5, 1.0), (5, 1.25), (5, 1.5), (5, 1.75), (5, 2.0), (60, 0.001), (60, 0.0025), (60, 0.005), (60, 0.0075), (60, 0.01), (60, 0.025), (60, 0.05), (60, 0.075), (60, 0.1), (60, 0.25), (60, 0.5), (60, 0.75), (60, 1.0), (60, 1.25)],
         '130828CKL U01SAII': [(3, 0.5), (3, 0.75), (3, 1.0), (3, 1.25), (3, 1.5), (3, 1.75), (3, 2.0), (5, 0.075), (5, 0.1), (5, 0.25), (5, 0.5), (5, 0.75), (5, 1.0), (5, 1.25), (5, 1.5), (5, 1.75), (5, 2.0), (8, 0.1), (8, 0.25), (8, 0.5), (8, 0.75), (8, 1.0), (8, 1.25), (8, 1.5), (8, 1.75), (10, 0.05), (10, 0.075), (10, 0.1), (10, 0.25), (10, 0.5), (10, 0.75), (10, 1.0), (10, 1.25), (10, 1.5), (10, 1.75), (10, 2.0), (20, 0.05), (20, 0.075), (20, 0.1), (20, 0.25), (20, 0.5), (20, 0.75), (20, 1.0), (20, 1.25), (20, 1.5), (20, 1.75), (20, 2.0), (30, 0.005), (30, 0.0075), (30, 0.01), (30, 0.025), (30, 0.05), (30, 0.075), (30, 0.1), (30, 0.25), (30, 0.5), (30, 0.75), (30, 1.0), (30, 1.25), (30, 1.5), (30, 1.75), (30, 2.0), (60, 0.001), (60, 0.0025), (60, 0.005), (60, 0.0075), (60, 0.01), (60, 0.025), (60, 0.05), (60, 0.075), (60, 0.1), (60, 0.25), (60, 0.5), (60, 0.75), (60, 1.0), (60, 1.25), (60, 1.5)],
         '140819GG U01SAII': [(5, 0.075), (5, 0.1), (5, 0.25), (5, 0.5), (5, 0.75), (5, 1.0), (5, 1.25), (8, 0.05), (8, 0.075), (8, 0.1), (8, 0.25), (8, 0.5), (8, 0.75), (8, 1.0), (8, 1.25), (8, 1.5), (8, 1.75), (8, 2.0), (10, 0.05), (10, 0.075), (10, 0.1), (10, 0.25), (10, 0.5), (10, 0.75), (10, 1.0), (10, 1.25), (10, 1.5), (10, 1.75), (10, 2.0), (20, 0.05), (20, 0.075), (20, 0.1), (20, 0.25), (20, 0.5), (20, 0.75), (20, 1.0), (20, 1.25), (20, 1.5), (20, 1.75), (20, 2.0)],
         '120710JPH U01 SAII': [(3, 0.5), (5, 0.1), (5, 0.25), (5, 0.5), (8, 0.1), (8, 0.25), (8, 0.5), (8, 0.75), (8, 1.0), (10, 0.05), (10, 0.075), (10, 0.1), (10, 0.25), (10, 0.5), (10, 0.75), (20, 0.05), (20, 0.075), (20, 0.1), (20, 0.25), (20, 0.5), (20, 0.75), (20, 1.0), (20, 1.25), (20, 1.5), (30, 0.005), (30, 0.0075), (30, 0.01), (30, 0.025), (30, 0.05), (30, 0.075), (30, 0.1), (30, 0.25), (30, 0.5), (30, 0.75), (30, 1.0), (30, 1.25), (30, 1.5), (60, 0.001), (60, 0.0025), (60, 0.005), (60, 0.0075), (60, 0.01), (60, 0.025), (60, 0.05), (60, 0.075), (60, 0.1), (60, 0.25), (60, 0.5), (60, 0.75), (60, 1.0), (60, 1.25)],
         '131031LRF U02 SAII': [(3, 0.1), (3, 0.25), (3, 0.5), (3, 0.75), (3, 1.0), (3, 1.25), (3, 1.5), (3, 1.75), (5, 0.075), (5, 0.1), (5, 0.25), (5, 0.5), (5, 0.75), (5, 1.0), (5, 1.25), (5, 1.5), (5, 1.75), (5, 2.0), (8, 0.05), (8, 0.075), (8, 0.1), (8, 0.25), (8, 0.5), (8, 0.75), (8, 1.0), (8, 1.25), (8, 1.5), (8, 1.75), (8, 2.0), (10, 0.05), (10, 0.075), (10, 0.1), (10, 0.25), (10, 0.5), (10, 0.75), (10, 1.0), (10, 1.25), (10, 1.5), (10, 1.75), (10, 2.0), (20, 0.05), (20, 0.075), (20, 0.1), (20, 0.25), (20, 0.5), (20, 0.75), (20, 1.0), (20, 1.25), (20, 1.5), (20, 1.75), (20, 2.0), (60, 0.001), (60, 0.0025), (60, 0.005), (60, 0.0075), (60, 0.01), (60, 0.025), (60, 0.05), (60, 0.075), (60, 0.1), (60, 0.25), (60, 0.5), (60, 0.75), (60, 1.0), (60, 1.25), (100, 0.001), (100, 0.0025), (100, 0.005), (100, 0.0075), (100, 0.01), (100, 0.025), (100, 0.05), (100, 0.075), (100, 0.1), (100, 0.25), (100, 0.5)]}

# ----------------------------------------- #

# FootSim generators #

# ----------------------------------------- #


def foot_populations():

    """ Generates footsim afferent populations placed in the same foot sole locations as described in

    Strzalkowski, N. D., Triano, J. J., Lam, C. K., Templeton, C. A., & Bent, L. R. (2015).
    Thresholds of skin sensitivity are partially influenced by mechanical properties of the skin on the foot sole.
    Physiological reports, 3(6), e12425.

    Arguments:

        None

     Returns:

        Dictionary of afferent populations

     """

    populations = dict()

    for location in fs.constants.foot_tags: # Create the populations and add them to the dictionary

        populations[location] = fs.AfferentPopulation()

    # Acquires the empirical locations from fs.constants #

    idx = 0

    for locSA1 in fs.constants.affregSA1:

        populations[locSA1].afferents.append(fs.Afferent(affclass='SA1', idx=int(idx),
                                                           location=fs.foot_surface.centers[fs.foot_surface.tag2idx(locSA1)[0]]))

        idx = idx + 1

    idx = 0

    for locSA2 in fs.constants.affregSA2:

        populations[locSA2].afferents.append(fs.Afferent(affclass='SA2', idx=int(idx),
                                                         location=fs.foot_surface.centers[
                                                             fs.foot_surface.tag2idx(locSA2)[0]]))

        idx = idx + 1

    idx = 0

    for locFA1 in fs.constants.affregFA1:

        populations[locFA1].afferents.append(fs.Afferent(affclass='FA1', idx=int(idx),
                                                           location=fs.foot_surface.centers[fs.foot_surface.tag2idx(locFA1)[0]]))

        idx = idx + 1

    idx = 0

    for locFA2 in fs.constants.affregFA2:

        populations[locFA2].afferents.append(fs.Afferent(affclass='FA2', idx=int(idx),
                                                           location=fs.foot_surface.centers[fs.foot_surface.tag2idx(locFA2)[0]]))

        idx = idx + 1

    return populations


# ----------------------------------------- #

# FootSim's model statistics #

# ----------------------------------------- #


def class_FRs(FRs):

    """ Groups the comparative dictionaries in between footsim outputs and the biological responses for a given set
       of amplitudes and frequencies of stimulus generated with individual_FRs()

        Arguments:

            FRs(dict): Dictionary with responses

        Returns:

           Four dictionaries of responses, one per afferent class
        """

    FAI = dict()
    FAII = dict()
    SAI = dict()
    SAII = dict()

    for keys in FRs:

        if "FAII" in keys:

            FAII[keys] = FRs[keys]

        if "SAII" in keys:

            SAII[keys] = FRs[keys]

    for keys in FAII:

        del FRs[keys]

    for keys in SAII:

        del FRs[keys]

    for keys in FRs:

        if "FAI" in keys:

            FAI[keys] = FRs[keys]

        if "SAI" in keys:

            SAI[keys] = FRs[keys]

    FS_classes = dict()

    FS_classes['FAI'] = FAI
    FS_classes['FAII'] = FAII
    FS_classes['SAI'] = SAI
    FS_classes['SAII'] = SAII

    return FS_classes


def individual_FRs(figpath, scatter=True):

    """ Compares Footsim outputs and the original biological responses for a given set of amplitudes and frequencies of
     stimulus.

        Arguments:

            figpath(str): Where to save result plots

        Returns:

           Dictionary of firing rates for each stimulus for both footsim and empirical data in position 0 and stimulus
           pairs in position 1

        """

    populations = foot_populations()  # Generates the affpop
    footsim_rates = model_firing_rates(populations=populations, pairs=pairs, matched=True)

    comparison = dict()  # Dictionary that will get all the rates from the model

    for keys in footsim_rates:

       for t in range(0, len(footsim_rates[keys])):

            afferent_c = t  # Enquires with afferent
            afferent_class = populations[keys[2]][afferent_c].affclass  # Gathers its class
            idx = populations[keys[2]][afferent_c].idx  # Gathers its model number

            comparison[fs.constants.affid[afferent_class][idx]] = list()
            comparison[fs.constants.affid[afferent_class][idx]].append(list())  # FRs
            comparison[fs.constants.affid[afferent_class][idx]].append(list())  # Stimulus pairs

    for keys in footsim_rates:

        for t in range(0, len(footsim_rates[keys])):

            afferent_c = t  # Enquires with afferent
            afferent_class = populations[keys[2]][afferent_c].affclass  # Gathers its class
            idx = populations[keys[2]][afferent_c].idx  # Gathers its model number

            comparison[fs.constants.affid[afferent_class][idx]][1].append((keys[0], keys[1]))

            if isinstance(footsim_rates[keys][t], np.ndarray) == True:

                comparison[fs.constants.affid[afferent_class][idx]][0].append(footsim_rates[keys][t][0][0])

            else:

                comparison[fs.constants.affid[afferent_class][idx]][0].append(footsim_rates[keys][t])

    return comparison


def model_firing_rates(populations, pairs, matched=True):

    """ Computes the firing rates (Hz) of an afferent population for a given set of frequencies and amplitudes of
    stimulus

         Arguments:

             populations (dict): Dictionary with foot locations as keys and afferent populations as values
             pairs(dict): Hardcoded dictionary of empirical stimulation

         Returns:

            Dictionary of populational firing rates with amplitude, frequency and location of stimulus as keys

            # Keys of the output dictionary:

                # 0 = Amplitude of stimulus
                # 1 = Frequency of stimulus
                # 2 = Location where the afferent was tested

         """


    if not matched:

        stim_all = list(set().union(*list(pairs.values())))
        pairs_all = dict()
        for k in pairs.keys():
            pairs_all[k] = stim_all
        pairs = pairs_all

    s = dict()  # Stimulus
    r = dict()  # Responses
    rates = dict()  # Firing rates
    populational_stimulus = dict()

    for location in populations:

        populational_stimulus[location] = list()

        if len(populations[location]) != 0:

            for afferent in range(0, len(populations[location])):

                afferent_id = fs.constants.affid[populations[location]
                    .afferents[afferent].affclass][populations[location].afferents[afferent].idx]

                for stimulation in range(0, len(pairs[afferent_id])):

                    rates[pairs[afferent_id][stimulation][1], pairs[afferent_id][stimulation][0], location] = list()

                    for afferent_t in range(0, len(populations[location])):

                        rates[pairs[afferent_id][stimulation][1], pairs[afferent_id][stimulation][0], location]\
                            .append(np.nan)

    print("Computing firing rates...")

    for location in populations:

        if len(populations[location]) != 0:

            for afferent in range(0, len(populations[location])):

                afferent_id = fs.constants.affid[populations[location]
                    .afferents[afferent].affclass][populations[location].afferents[afferent].idx]

                populational_stimulus[location].extend(pairs[afferent_id])  # Grouping populational stimulus given

                for stimulation in range(0, len(pairs[afferent_id])):

                    # Stimulus based on empirical data - Pairs are frequency and amplitude#

                    s[pairs[afferent_id][stimulation][1], pairs[afferent_id][stimulation][0], location] = \
                        fs.stim_sine(amp=pairs[afferent_id][stimulation][1] / 2,
                                     freq=pairs[afferent_id][stimulation][0], pin_radius=3,
                                     loc=fs.foot_surface.centers[fs.foot_surface.tag2idx(str(location))[0]],
                                     ramp_type='sin', len=2)

                    # Gathers responses #

                    r[pairs[afferent_id][stimulation][1], pairs[afferent_id][stimulation][0], location] = \
                        populations[location].afferents[afferent].response(s[pairs[afferent_id][stimulation][1],
                                                         pairs[afferent_id][stimulation][0], location])

                    # Computes firing rates #

                    rates[pairs[afferent_id][stimulation][1], pairs[afferent_id][stimulation][0], location][afferent] =\
                        r[pairs[afferent_id][stimulation][1], pairs[afferent_id][stimulation][0], location].rate()

            for afferent in range(0, len(populations[location])):

                afferent_id = fs.constants.affid[populations[location]
                    .afferents[afferent].affclass][populations[location].afferents[afferent].idx]

                for every_stimulus in populational_stimulus[location]:

                    if every_stimulus not in pairs[afferent_id]:

                        rates[every_stimulus[1],every_stimulus[0], location][afferent] = np.nan

    return rates


def model_RFs():

    """ Computes the receptive field area in mm^2 for footsim afferents.


    Returns:

        Dictionary of receptive field areas for the afferent models of footsim

    """

    RF_mod = dict()

    for a in fs.constants.affclasses:
        RF_mod[a] = dict()
        for i in range(fs.constants.affparams[a].shape[0]):
            RF_mod[a][fs.constants.affid[a][i]] = single_RF(a, i)

    return RF_mod


def individual_models_thresholds(absolute, matched=True):

    """ Find the absolute thresholds of all afferent models generated with regional_afferent_positioning()
     for a given set of frequencies and amplitudes of stimulus

     # Keys of the individual_min (AFT) and of the individual_models_thresholds dictionary:

        # 0 = Afferent class
        # 1 = Model number (idx)
        # 2 = Location on the foot sole
        # 3 = Frequency where that response happened

        Arguments:

            absolute (float): Firing threshold in Hz


        Returns:

           Dictionary of minimum responsive amplitudes grouped per afferent model.

        """

    individual_models_thresholds = get_responsive_amplitudes(absolute=absolute, output="I", matched=matched)

    individual_min = dict()

    for keys in individual_models_thresholds:

        if len(individual_models_thresholds[keys]) > 0:

            individual_min[keys] = np.min(individual_models_thresholds[keys])

        else:

            individual_min[keys] = np.nan

    return individual_min


def ramps_byclass(figpath, figname):

    """ Function that computes and plots ramp stimulus and responses

       Arguments:

           figpath(str): Path to save results
           figname(str): Name of the results figure

        Returns:

           *.svg plot of the results

        """

    fig = plt.figure(figsize=(7, 5.5))
    t = np.linspace(0, 1, 100)

    ramps = dict()
    for aix, aff in enumerate(['SA1', 'SA2', 'FA1', 'FA2']):

        ramps[aff] = np.zeros((fs.constants.affparams[aff].shape[0], 100))

        for i in range(fs.constants.affparams[aff].shape[0]):

            reg = fs.constants.affreg[aff][i]
            sur = fs.Surface(tags=[reg])

            # place Afferent
            a = fs.Afferent(affclass=aff, idx=i, surface=sur)

            # generate ramp to centre of foot region
            s = fs.stim_ramp(amp=2, ramp_type='sin', len=0.9, ramp_len=0.25,
                             pad_len=0.05, pin_radius=3, surface=sur)

            r = a.response(s)
            ramps[aff][i] = r.psth()

        resp = np.convolve(np.mean(ramps[aff], axis=0), [.25, .5, .25], mode='same') * 100.

        ax = plt.subplot(2, 2, aix + 1)

        if aix == 3:
            plt.ylim((0., 220))
            plt.plot(t, 100. * scipy.signal.resample(s.trace[0], 100), color='k')

        else:
            plt.ylim((0., 110))
            plt.plot(t, 50. * scipy.signal.resample(s.trace[0], 100), color='k')

        plt.plot(t, resp, color=fs.constants.affcol[aff], linewidth=2)
        ax.set_xlabel("Time")
        ax.set_ylabel("Firing rate / Ramp stimulus")
        ax.spines['top'].set_visible(False)
        ax.spines['right'].set_visible(False)

    fig.tight_layout(rect=[0, 0.03, 1, 0.95])
    plt.savefig(figpath + figname, format='svg')

    return ramps, s


def single_RF(affclass, idx):

    """ Computes the receptive field area in mm^2 for a given afferent.

        Arguments:

            affclass(str): Afferent class of the population being tested.
            idx(int): Afferent model to be tested

        Returns:

            Receptive field area for the selected afferent

        """

    reg = fs.constants.affreg[affclass][idx]
    sur = fs.Surface(tags=[reg])

    ff = {'SA1':5, 'SA2':5, 'FA1':40, 'FA2':150}

    depths = np.linspace(0.005,0.5,45)
    min_loc = 0
    max_loc = 60
    thres_rate = 2

    # find threshold
    a = fs.Afferent(affclass=affclass,idx=idx,surface=sur)

    rr_thres = np.zeros(depths.shape)
    for i,d in enumerate(depths):
        s = fs.stim_sine(amp=d,freq=ff[affclass],pin_radius=1.,surface=sur)
        r = a.response(s)
        rr_thres[i] = r.rate()[0,0]

    try:
        thres_ind = np.argwhere(rr_thres>thres_rate)[0]
    except:
        return np.nan

    # find minimal responding distance
    s = fs.stim_sine(amp=depths[thres_ind]*3,freq=ff[affclass],pin_radius=1.,surface=sur)
    for i in range(10):
        a = fs.affpop_linear(min_dist=min_loc,max_dist=max_loc,num=3,affclass=affclass,idx=idx,surface=sur)
        r = a.response(s)
        rr = r.rate().flatten()

        try:
            ix = np.argwhere(rr<=thres_rate)[0]
        except:
            return np.nan

        if ix is None or ix==0:
            break
        max_loc = a.location[ix,0]
        min_loc = a.location[ix-1,0]

    return ((max_loc+min_loc)/2.+1.)


# ----------------------------------------- #

# Data visualisation #

# ----------------------------------------- #


def individual_models_threshold_visualisation(absolute, figpath, matched=True):

    """ Plots the absolute thresholds of individual afferent models for a given set of frequencies and amplitudes of
    stimulus

        Arguments:

        absolute (float): Absolute firing threshold in Hz
        figpath(str): Where to save result plots

         Returns:

            Plots thresholds per frequency in log scale.
         """

    SA1 = dict()
    SA2 = dict()

    FA1 = dict()
    FA2 = dict()

    stimulus_pairs = dict()
    responsive_freqs = dict()

    # Get the population for looping purposes
    populations = foot_populations()

    individual_min = individual_models_thresholds(absolute=absolute, matched=matched)

    # Keys of the individual_min (AFT) dictionary:

    # 0 = Afferent class
    # 1 = Model number (idx)
    # 2 = Location on the foot sole
    # 3 = Frequency where that response happened

    for keys in individual_min:  # Creating the lists #

        if keys[0] == 'SA1' and keys[2] != "T3_t" and keys[2] != "T4_t" and keys[2] != "T5_t":

            for loc in fs.constants.foot_tags:

                if keys[2] == loc:

                    for afferent in range(len(populations[keys[2]])):  # Loops through afferents in that location

                        if fs.foot_surface.locate(populations[keys[2]].afferents[afferent].location)[0][0] == loc \
                                and populations[keys[2]].afferents[afferent].affclass == keys[0] \
                                and keys[1] == populations[keys[2]].afferents[afferent].idx:
                            stimulus_pairs[keys[0], keys[1], keys[2]] = list()
                            SA1[keys[1], keys[2]] = list()
                            responsive_freqs[keys[0], keys[1], keys[2]] = list()

        elif keys[0] == 'FA1' and keys[2] != "T3_t" and keys[2] != "T4_t" and keys[2] != "T5_t":

            for loc in fs.constants.foot_tags:

                if keys[2] == loc:

                    for afferent in range(len(populations[keys[2]])):  # Loops through afferents in that location

                        if fs.foot_surface.locate(populations[keys[2]].afferents[afferent].location)[0][0] == loc \
                                and populations[keys[2]].afferents[afferent].affclass == keys[0] \
                                and keys[1] == populations[keys[2]].afferents[afferent].idx:
                            stimulus_pairs[keys[0], keys[1], keys[2]] = list()
                            FA1[keys[1], keys[2]] = list()
                            responsive_freqs[keys[0], keys[1], keys[2]] = list()

        elif keys[0] == 'SA2' and keys[2] != "T3_t" and keys[2] != "T4_t" and keys[2] != "T5_t":

            for loc in fs.constants.foot_tags:

                if keys[2] == loc:

                    for afferent in range(len(populations[keys[2]])):  # Loops through afferents in that location

                        if fs.foot_surface.locate(populations[keys[2]].afferents[afferent].location)[0][0] == loc \
                                and populations[keys[2]].afferents[afferent].affclass == keys[0] \
                                and keys[1] == populations[keys[2]].afferents[afferent].idx:
                            stimulus_pairs[keys[0], keys[1], keys[2]] = list()
                            SA2[keys[1], keys[2]] = list()
                            responsive_freqs[keys[0], keys[1], keys[2]] = list()

        elif keys[0] == 'FA2' and keys[2] != "T3_t" and keys[2] != "T4_t" and keys[2] != "T5_t":

            for loc in fs.constants.foot_tags:

                if keys[2] == loc:

                    for afferent in range(len(populations[keys[2]])):  # Loops through afferents in that location

                        if fs.foot_surface.locate(populations[keys[2]].afferents[afferent].location)[0][0] == loc \
                                and populations[keys[2]].afferents[afferent].affclass == keys[0] \
                                and keys[1] == populations[keys[2]].afferents[afferent].idx:
                            stimulus_pairs[keys[0], keys[1], keys[2]] = list()
                            FA2[keys[1], keys[2]] = list()
                            responsive_freqs[keys[0], keys[1], keys[2]] = list()


    for keys in individual_min:  # Grouping the responsive amplitudes #

        if keys[0] == 'SA1' and keys[2] != "T3_t" and keys[2] != "T4_t" and keys[2] != "T5_t":

            for loc in fs.constants.foot_tags:

                if keys[2] == loc:

                    for afferent in range(len(populations[keys[2]])):  # Loops through afferents in that location

                        if fs.foot_surface.locate(populations[keys[2]].afferents[afferent].location)[0][0] == loc \
                                and populations[keys[2]].afferents[afferent].affclass == keys[0] \
                                and keys[1] == populations[keys[2]].afferents[afferent].idx:

                            SA1[populations[keys[2]].afferents[afferent].idx, loc].append(individual_min[keys])
                            stimulus_pairs[keys[0], keys[1], keys[2]].append((keys[3], individual_min[keys]))
                            responsive_freqs[keys[0], keys[1], keys[2]].append(keys[3])

        elif keys[0] == 'FA1' and keys[2] != "T3_t" and keys[2] != "T4_t" and keys[2] != "T5_t":

            for loc in fs.constants.foot_tags:

                if keys[2] == loc:

                    for afferent in range(len(populations[keys[2]])):  # Loops through afferents in that location

                        if fs.foot_surface.locate(populations[keys[2]].afferents[afferent].location)[0][0] == loc \
                                and populations[keys[2]].afferents[afferent].affclass == keys[0] \
                                and keys[1] == populations[keys[2]].afferents[afferent].idx:
                            FA1[populations[keys[2]].afferents[afferent].idx, loc].append(individual_min[keys])
                            stimulus_pairs[keys[0], keys[1], keys[2]].append((keys[3], individual_min[keys]))
                            responsive_freqs[keys[0], keys[1], keys[2]].append(keys[3])

        elif keys[0] == 'SA2' and keys[2] != "T3_t" and keys[2] != "T4_t" and keys[2] != "T5_t":

            for loc in fs.constants.foot_tags:

                if keys[2] == loc:

                    for afferent in range(len(populations[keys[2]])):  # Loops through afferents in that location

                        if fs.foot_surface.locate(populations[keys[2]].afferents[afferent].location)[0][0] == loc \
                                and populations[keys[2]].afferents[afferent].affclass == keys[0] \
                                and keys[1] == populations[keys[2]].afferents[afferent].idx:
                            SA2[populations[keys[2]].afferents[afferent].idx, loc].append(individual_min[keys])
                            stimulus_pairs[keys[0], keys[1], keys[2]].append((keys[3], individual_min[keys]))
                            responsive_freqs[keys[0], keys[1], keys[2]].append(keys[3])

        elif keys[0] == 'FA2' and keys[2] != "T3_t" and keys[2] != "T4_t" and keys[2] != "T5_t":

            for loc in fs.constants.foot_tags:

                if keys[2] == loc:

                    for afferent in range(len(populations[keys[2]])):  # Loops through afferents in that location

                        if fs.foot_surface.locate(populations[keys[2]].afferents[afferent].location)[0][0] == loc \
                                and populations[keys[2]].afferents[afferent].affclass == keys[0] \
                                and keys[1] == populations[keys[2]].afferents[afferent].idx:
                            FA2[populations[keys[2]].afferents[afferent].idx, loc].append(individual_min[keys])
                            stimulus_pairs[keys[0], keys[1], keys[2]].append((keys[3], individual_min[keys]))
                            responsive_freqs[keys[0], keys[1], keys[2]].append(keys[3])

    grouped_thresholds = dict()  # Groups the results per afferent class
    grouped_thresholds['FA1'] = FA1
    grouped_thresholds['FA2'] = FA2
    grouped_thresholds['SA1'] = SA1
    grouped_thresholds['SA2'] = SA2

    # ----------------------------------------- #

    # Generating Figures #

    # ----------------------------------------- #

    fig = plt.figure(figsize=(15, 5), dpi=500)

    sns.set_style("ticks")

    sns.set_context(context='notebook', rc={"font.size": 10, "axes.titlesize": 20, "axes.labelsize": 15,
                                            "lines.linewidth": 2, "xtick.labelsize": 12,
                                            "ytick.labelsize": 12})
    fig.suptitle("FootSim", fontsize=22, y=1)

    sns.set_palette("Blues")
    ax = plt.subplot(1, 4, 1)

    for keys in FA1:

        idx = np.argsort(np.array(responsive_freqs['FA1', keys[0], keys[1]]))
        plt.plot(np.array(responsive_freqs['FA1', keys[0], keys[1]])[idx], np.array(FA1[keys])[idx])

    plt.yscale("log")
    plt.xscale("log")
    plt.ylim([10 ** -3, 10 ** 1])
    plt.xlim([1, 1000])
    ax.set(xlabel='Frequency', ylabel='Amplitude')
    ax.spines['top'].set_visible(False)
    ax.spines['right'].set_visible(False)

    sns.set_palette("Reds")
    ax = plt.subplot(1, 4, 2)

    for keys in FA2:

        idx = np.argsort(np.array(responsive_freqs['FA2', keys[0], keys[1]]))
        plt.plot(np.array(responsive_freqs['FA2', keys[0], keys[1]])[idx], np.array(FA2[keys])[idx])

    plt.yscale("log")
    plt.xscale("log")
    plt.ylim([10 ** -3, 10 ** 1])
    plt.xlim([1, 1000])
    ax.set(xlabel='Frequency', ylabel='Amplitude')
    ax.spines['top'].set_visible(False)
    ax.spines['right'].set_visible(False)

    sns.set_palette("Greens")
    ax = plt.subplot(1, 4, 3)

    for keys in SA1:

        idx = np.argsort(np.array(responsive_freqs['SA1', keys[0], keys[1]]))
        plt.plot(np.array(responsive_freqs['SA1', keys[0], keys[1]])[idx], np.array(SA1[keys])[idx])

    plt.yscale("log")
    plt.xscale("log")
    plt.ylim([10 ** -3, 10 ** 1])
    plt.xlim([1, 1000])
    ax.set(xlabel='Frequency', ylabel='Amplitude')
    ax.spines['top'].set_visible(False)
    ax.spines['right'].set_visible(False)

    sns.set_palette("Greys")
    ax = plt.subplot(1, 4, 4)

    for keys in SA2:

        idx = np.argsort(np.array(responsive_freqs['SA2', keys[0], keys[1]]))
        plt.plot(np.array(responsive_freqs['SA2', keys[0], keys[1]])[idx], np.array(SA2[keys])[idx])

    plt.yscale("log")
    plt.xscale("log")
    plt.ylim([10 ** -3, 10 ** 1])
    plt.xlim([1, 1000])
    ax.set(xlabel='Frequency', ylabel='Amplitude')
    ax.spines['top'].set_visible(False)
    ax.spines['right'].set_visible(False)

    fig.tight_layout()
    plt.show()
    plt.savefig(figpath + "Thres_mod_" + str(absolute) + "_Hz.svg", format='svg')

    return grouped_thresholds, stimulus_pairs


def FR_scatters(figpath, comparison, figname):

    """ Generate the comparative scatter plots in between footsim outputs and the biological responses for a given set
    of amplitudes and frequencies of stimulus generated with FR_model_vs_empirical() or ImpCycle_model_vs_empirical()

     Arguments:

         comparison(dict): Dictionary with both responses
         figpath(str): Where to save result plots
         figname(str): Output file name

     Returns:

        Comparative plots
     """

    plotcount = 1

    FS_classes = class_FRs(FRs=comparison)  # Grouping the FR per affclass

    fig = plt.figure(figsize=(28, 22), dpi=200)

    sns.set(style='white', font_scale=2)

    sns.set_context("talk", rc={"font.size": 20, "axes.titlesize": 20, "axes.labelsize": 15, "lines.linewidth": 5,
                                "xtick.labelsize": 15, "ytick.labelsize": 15, "lines.markersize": 10})

    for c in FS_classes:

        for keys in sorted(FS_classes[c]):

            if len(FS_classes[c][keys][0]) > 0:

                plt.subplot(6, 9, plotcount)

                ax = sns.scatterplot(data=np.array(FS_classes[c][keys][0]),
                                     color=fs.constants.affcol[fs.constants.affclass_mapping[c]])
                ax.set_title(keys, pad=10)

                ax.set(xlabel="Stimulus pairs", ylabel="Firing Rates")
                #plt.plot([0, max(FS_classes[c][keys])], [0, max(FS_classes[c][keys])], color='k')
                plotcount = plotcount + 1

    fig.tight_layout(rect=[0, 0.03, 1, 0.95])
    plt.savefig(figpath + figname, format='png')

    return 0


def FR_groupedscatters(figpath, comparison, figname):

    """ Generate the grouped scatter plots of footsim outputs for a given set of amplitudes and frequencies of stimulus
    Stimulus will be colour-coded in the plot

         Arguments:

             comparison(dict): Dictionary with both responses
             figpath(str): Where to save result plots
             figname(str): Output file name

         Returns:

            Comparative plots
         """

    plotcount = 1

    FS_classes = class_FRs(FRs=comparison)  # Grouping the FR per affclass

    classes = ['FAI', 'FAII', 'SAI', 'SAII']
    lim ={'FAI':320, 'FAII':320, 'SAI':100, 'SAII':100}

    fig = plt.figure(figsize=(10, 10), dpi=200)

    all_freqs = np.array([3, 5, 8, 10, 20, 30, 60, 100, 150, 250])
    idx = np.linspace(0,1,all_freqs.size)
    col = dict()
    for i,f in enumerate(all_freqs):

        col[f] = plt.cm.plasma(idx[i])

    for c in classes:

        ax = plt.subplot(2, 2, plotcount)

        ax.spines['top'].set_visible(False)
        ax.spines['right'].set_visible(False)
        #ax.set_aspect('equal')
        ax.set_title(str(c))
        ax.set_xlabel("Stimulus pairs")
        ax.set_xlim([0, 20])
        ax.set_ylabel("Firing rate")
        sns.set_style("ticks")

        #plt.plot([0,lim[c]] ,color='black')
        spacing = 0.5
        fig.subplots_adjust(bottom=spacing)

        for keys in sorted(FS_classes[c]):

            r_mod = np.array(FS_classes[c][keys][0])
            stim = np.array(FS_classes[c][keys][1])
            freqs = np.unique(stim[:,1])

            for f in freqs:

                idx = stim[:,1]==f
                sns.scatterplot(data=r_mod[idx], color=col[f], zorder=f)

        plotcount = plotcount + 1

    fig.tight_layout(rect=[0, 0.03, 1, 0.95])
    plt.savefig(figpath+figname, format='svg')


def FR_intensity_functions(figpath, comparison, figname):

    """ Generate the rate intensity plots for footsim outputs

         Arguments:

             comparison(dict): Dictionary with both responses
             figpath(str): Where to save result plots
             figname(str): Output file name

         Returns:

           Plots
         """

    plotcount = 1

    FS_classes = class_FRs(FRs=comparison) # Grouping the FR per affclass

    classes = ['FAI', 'FAII', 'SAI', 'SAII']

    fig = plt.figure(figsize=(28, 22), dpi=200)

    all_freqs = np.array([3, 5, 8, 10, 20, 30, 60, 100, 150, 250])

    idx = np.linspace(0, 1, all_freqs.size)
    col = dict()
    for i,f in enumerate(all_freqs):
        col[f] = plt.cm.plasma(idx[i])

    for c in classes:

        for keys in sorted(FS_classes[c]):

            r_mod = np.array(FS_classes[c][keys][0])
            stim = np.array(FS_classes[c][keys][1])
            freqs = np.unique(stim[:,1])

            ax = plt.subplot(6, 9, plotcount)
            ax.spines['top'].set_visible(False)
            ax.spines['right'].set_visible(False)
            ax.set_title(keys, pad=10)
            plt.xscale('log')
            plt.xlim(0.01,2)

            hd = []
            for f in freqs:
                idx = stim[:,1]==f
                ss = stim[idx,0]
                rm = r_mod[idx]
                ix = np.argsort(ss)
                base_line, = plt.plot(ss[ix], rm[ix], linewidth=2, color=col[f], alpha=0.5, label=f)
                hd.append(base_line)

            plotcount = plotcount + 1

    fig.tight_layout(rect=[0, 0.03, 1, 0.95])
    plt.savefig(figpath+figname, format='svg')


def RFs_swarm(figpath, figname, RF_mod):

    """ Plots the receptive field areas in mm^2 for FootSim.

        Arguments:

            figpath(str): Path of the folder where the results will be saved
            figname(str): Name of the results figure to be saved
            RF_mod(dict): Dictionary generated by model_rfs()

        Returns:

            Receptive field area for the selected afferent

        """

    classes = ['SA1', 'SA2', 'FA1', 'FA2']

    rf_mod = pd.DataFrame(columns=['Class', 'RF size'])

    counter = 0

    for c in classes:
        aff = RF_mod[c].keys()
        for a in aff:
            if np.isnan(RF_mod[c][a]):
                continue
            rf_mod.loc[counter] = [c, RF_mod[c][a]]
            counter += 1

    fig = plt.figure(figsize=(7, 5.5), dpi=200)
    ax = sns.swarmplot(x='Class', y='RF size', data=rf_mod, hue='Class', palette=fs.constants.affcol)
    ax.spines['top'].set_visible(False)
    ax.spines['right'].set_visible(False)
    ax.set(ylim=(0, 31))

    fig.tight_layout(rect=[0, 0.03, 1, 0.95])
    plt.savefig(figpath + figname, format='svg')

    return rf_mod


# ----------------------------------------- #

# Supplementary functions #

# ----------------------------------------- #


def correct_FRoutputs(FRs):

    """ Quick function to reformat the data structure containing the FootSim firing rates


       Arguments:

           FRs(dict): Dicionary of firing rates

        Returns:

           np.array of firing rates

        """


    clean_array = list()

    for items in FRs:

        if type(items) == np.ndarray:

            clean_array.append(items[0][0])

        else:

            clean_array.append(np.nan)

    return clean_array


def get_responsive_amplitudes(absolute, output, matched=True, threshold_type='A'):

    """ Investigate the responses of an afferent population for a given set of frequencies and amplitudes of stimulus
    computing responses for either absolute of tuning thresholds and grouping the results by afferent class,
    location or model id.


         Arguments:

             absolute (float): Absolute firing threshold in Hz
             figpath(str): Where to save result plots
             output(str): Type of output required, C for class, I for individual models, R for regions

         Returns:

            Dictionary of responsive amplitudes for afferents grouped by by afferent class, location or model id.

                # Keys of the returned dictionary, if output == "I":

                    # 0 = Afferent class
                    # 1 = Model number (idx)
                    # 2 = Location on the foot sole
                    # 3 = Frequency where that response happened
         """

    start = time.asctime(time.localtime(time.time()))

    populations = foot_populations()
    responsive_afferents = dict()
    regional_responsive_amplitudes = dict()
    class_responsive_amplitudes = dict()
    response_of_individual_models = dict()

    rates = model_firing_rates(populations, pairs=pairs, matched=True)

    for keys in rates.keys():

        rates[keys] = correct_FRoutputs(rates[keys])

    for keys in rates.keys():

        if threshold_type == "T":

            tuning = 0.8 * keys[1]
            responsive_afferents[keys] = np.where(rates[keys] > tuning)

            responsive_afferents[keys] = responsive_afferents[keys][0]

        if threshold_type == "A":

            responsive_afferents[keys] = np.where(np.array(rates[keys], dtype=object) > absolute)

            if len(responsive_afferents[keys]) > 0:

                responsive_afferents[keys] = responsive_afferents[keys][0]

            else:

                responsive_afferents[keys] = []

            # For each afferent that responded #

            for t in range(0, len(responsive_afferents[keys])):

                afferent_c = int(responsive_afferents[keys][t])

                afferent_class = populations[keys[2]][afferent_c].affclass  # Gathers its class

                idx = populations[keys[2]][afferent_c].idx

                # Appends the amplitudes where it was responsive #

                try:
                    regional_responsive_amplitudes[afferent_class, keys[2], keys[1]].append(keys[0])

                except:
                    regional_responsive_amplitudes[afferent_class, keys[2], keys[1]] = [keys[0]]

                try:
                    class_responsive_amplitudes[afferent_class, keys[1]].append(keys[0])

                except:
                    class_responsive_amplitudes[afferent_class, keys[1]] = [keys[0]]

                try:
                    response_of_individual_models[afferent_class, idx, keys[2], keys[1]].append(keys[0])

                except:
                    response_of_individual_models[afferent_class, idx, keys[2], keys[1]] = [keys[0]]

    print("Simulation started at: ", start)
    print("Simulation finished at: ", time.asctime(time.localtime(time.time())))

    userinput = output

    if userinput == "R":

        return regional_responsive_amplitudes

    elif userinput == "C":

        return class_responsive_amplitudes

    elif userinput == "I":

        return response_of_individual_models
